{
  "name": "vash",
  "description": "Razor syntax for JS templating",
  "version": "0.7.12-1",
  "author": {
    "name": "Andrew Petersen",
    "email": "senofpeter@gmail.com"
  },
  "homepage": "https://github.com/kirbysayshi/vash",
  "bin": {
    "vash": "./bin/vash"
  },
  "keywords": [
    "razor",
    "parser",
    "template",
    "express"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/kirbysayshi/vash"
  },
  "main": "build/vash",
  "engines": {
    "node": ">= 0.8"
  },
  "scripts": {
    "build": "make build",
    "test": "make test && make test-min",
    "docs": "make docs"
  },
  "dependencies": {
    "commander": "~1.1.1",
    "uglify-js": "1.0.6"
  },
  "devDependencies": {
    "vows": "~0.7.0",
    "semver": "~1",
    "jshint": "0.8.0",
    "marked": "~0.2.8"
  },
  "contributors": [
    {
      "name": "Andrew Petersen",
      "email": "senofpeter@gmail.com",
      "url": "http://kirbysayshi.com"
    },
    {
      "name": "Roy Haddad",
      "email": "roy.haddad@gmail.com"
    },
    {
      "name": "Ron Otten",
      "email": "r.j.g.otten@gmail.com"
    }
  ],
  "readme": "<!-- This document was generated from README.vash -->\n\n\nVash\n====\n\n_\"... the 60 billion double-dollar template-maker!\"_ ~ The previous README, and no one else, ever.\n\nVash is a template engine that offers a swift flow between code and content using [Razor Syntax][] <sup id=\"fnref:razor-ms\">\n\t\t\t<a rel=\"footnote\" href=\"#fn:razor-ms\">1</a>\n\t\t</sup>. This document <sup id=\"fnref:this-doc\">\n\t\t\t<a rel=\"footnote\" href=\"#fn:this-doc\">2</a>\n\t\t</sup> is intended for users of Vash, and also serves as a reference for Vash's implementation of Razor Syntax.\n\n[Razor Syntax]: http://www.asp.net/web-pages/tutorials/basics/2-introduction-to-asp-net-web-programming-using-the-razor-syntax\n\n[![Build Status](https://secure.travis-ci.org/kirbysayshi/vash.png?branch=master)](https://travis-ci.org/kirbysayshi/vash)\n\n[![NPM](https://nodei.co/npm/vash.png?downloads=true&stars=true)](https://nodei.co/npm/vash/) [![NPM](https://nodei.co/npm-dl/vash.png)](https://nodei.co/npm/vash/)\n\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/kirbysayshi/vash/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\n\n\n- [Features](#features) \n- [Syntax Example](#syntax-example) \n- [Quick Start](#quick-start) \n  - [nodejs](#nodejs) \n  - [express](#express) \n  - [Browser - Vanilla](#browser---vanilla) \n  - [Browser - RequireJS](#browser---requirejs) \n- [Playground](#playground) \n- [Syntax](#syntax) \n  - [The Transition Character: @](#the-transition-character) \n  - [Expressions](#expressions) \n  - [Advanced Expressions](#advanced-expressions) \n  - [Explicit Expressions](#explicit-expressions) \n  - [Code Blocks](#code-blocks) \n  - [Keyword Blocks](#keyword-blocks) \n  - [Comments](#comments) \n  - [HTML Escaping](#html-escaping) \n  - [Explicit Markup](#explicit-markup) \n- [Configuration](#configuration) \n  - [vash.config.useWith](#vash-config-usewith) \n  - [vash.config.modelName](#vash-config-modelname) \n  - [vash.config.helpersName](#vash-config-helpersname) \n  - [vash.config.htmlEscape](#vash-config-htmlescape) \n  - [vash.config.debug](#vash-config-debug) \n  - [vash.config.debugParser](#vash-config-debugparser) \n  - [vash.config.debugCompiler](#vash-config-debugcompiler) \n  - [vash.config.simple](#vash-config-simple) \n  - [vash.config.favorText](#vash-config-favortext) \n- [Template Options](#template-options) \n  - [asContext](#ascontext) \n  - [onRenderEnd](#onrenderend) \n- [Helper System](#helper-system) \n- [Built-in Helpers](#built-in-helpers) \n  - [vash.helpers.raw](#vash-helpers-raw) \n  - [vash.helpers.escape](#vash-helpers-escape) \n  - [vash.helpers.tplcache](#vash-helpers-tplcache) \n- [Layout Helpers](#layout-helpers) \n  - [vash.helpers.extend](#vash-helpers-extend) \n  - [vash.helpers.block](#vash-helpers-block) \n  - [vash.helpers.append](#vash-helpers-append) \n  - [vash.helpers.prepend](#vash-helpers-prepend) \n  - [vash.helpers.include](#vash-helpers-include) \n- [Compiled Helpers](#compiled-helpers) \n- [Buffer API](#buffer-api) \n- [Precompiling Templates](#precompiling-templates) \n- [Vash Runtime (Browser)](#vash-runtime-browser) \n- [Compile-time API](#compile-time-api) \n  - [vash.compile](#vash-compile) \n  - [vash.compileHelper](#vash-compilehelper) \n  - [vash.compileBatch](#vash-compilebatch) \n- [Runtime API](#runtime-api) \n  - [vash.link](#vash-link) \n  - [vash.lookup](#vash-lookup) \n  - [vash.install](#vash-install) \n  - [vash.uninstall](#vash-uninstall) \n- [vash(1)](#vash-1) \n  - [Installation](#installation) \n  - [--target-namespace](#vash1--target-namespace) \n  - [--property-name](#vash1--property-name) \n  - [--helper](#vash1--helper) \n- [Contributing / Building](#contributing-building) \n- [Getting Help](#getting-help) \n- [Special Thanks](#special-thanks) \n- [License](#license) \n\n\n<a name=\"features\"></a>Features \n================\n\n* Mix code and content without ugly delineators, like `<?`, `<%`, or `{{`.\n* No new language to learn: Vash is just HTML-aware JavaScript.\n* Great with markup, but can be used with nearly any other language as well (even Markdown!).\n* Helpers API allows for extensibility and meta programming.\n* Works in the browser or in node.\n* Comes with a Jade-inspired layout engine (block, include, extend, append/prepend), which even works in the browser.\n\n<a name=\"syntax-example\"></a>Syntax Example \n======================\n\n\t<p>How are you @model.name? Today is a sunny day on the planet Gunsmoke.</p>\n\n\t<ul class=\"@(model.active ? 'highlight' : '')\">\n\t\t@model.forEach(function(m){\n\t\t\t<li>@m.name</li>\n\t\t})\n\t</ul>\n\n<a name=\"quick-start\"></a>Quick Start \n===================\n\n<a name=\"nodejs\"></a>nodejs \n--------------\n\n\tvar vash = require('vash');\n\tvar tpl = vash.compile('<p>I am a @model.t!</p>');\n\n\tvar out = tpl({ t: 'template' });\n\t// <p>I am a template!</p>\n\n<a name=\"express\"></a>express \n--------------------\n\nCheck out [vash-express-example][] for a full example of hooking up vash as a view engine for express 3. But it's basically as simple as:\n\n\tvar express = require('express');\n\n\tvar app = express();\n\tapp.set('view engine', 'vash');\n\nMore information is also available in the [Layout Helpers][] sections.\n\n[vash-express-example]: https://github.com/kirbysayshi/vash-express-example\n\n<a name=\"browser---vanilla\"></a>Browser - Vanilla \n-------------------------\n\n\t<script type=\"text/javascript\" src=\"vash.min.js\"></script>\n\n\tvar tpl = vash.compile( '<p>I am a @model.t!</p>' );\n\tdocument.querySelector('#content').innerHTML = tpl({ t: 'template' });\n\n<a name=\"browser---requirejs\"></a>Browser - RequireJS \n---------------------------\n\nBe sure to configure paths appropriately, but vash is AMD ready.\n\n\trequire(['vash'], function(vash){\n\t\tvar tpl = vash.compile( '<p>I am a @model.t!</p>' );\n\t\tdocument.querySelector('#content').innerHTML = tpl({ t: 'template' });\n\t})\n\n<a name=\"playground\"></a>Playground \n==================\n\nVash now has [a playground][] of sorts at [CodePen.io][]. It uses the current version of `vash.js` from the `build` folder. Fork it to test your own template ideas!\n\n[a playground]: http://codepen.io/kirbysayshi/full/IjrFw\n[CodePen.io]: http://codepen.io\n\n<a name=\"syntax\"></a>Syntax \n==============\n\nFor the following examples, assume a model is passed into the compiled function. If a model is explicitly defined, it will appear as:\n\n\t// model = { what: 'hello!' }\n\n<a name=\"the-transition-character\"></a>The Transition Character: @ \n------------------------------------\n\nVash uses the `@` symbol to transition between code and markup. To escape and print a literal `@`, use a double `@`, like this: `@@`.\n\n<a name=\"expressions\"></a>Expressions \n-------------------\n\nThe most basic usage of Vash is an implicit expression. Vash is smart enough to know what's valid JS and what's not, and can usually do what you want it to do. An expression is an @ followed by a valid JS identifier. This is then interpolated automatically.\n\ninput:\n\n\t// model = { what: 'hello!' }\n\t<p>@what</p>\n\noutput:\n\n\t<p>hello!</p>\n\nThe `model` comment is just to show that the object passed into the compiled template contains a key that matches the expression.\n\nTo allow for the fastest render time possible, Vash by default requires the model to be addressed explicitly. This is to avoid using a `with` statment in the compiled template, which is approximately 25 times slower. The above example then becomes:\n\ninput:\n\n\t<p>@model.what</p>\n\noutput:\n\n\t<p>hello!</p>\n\nAs you can see, the output is exactly the same. The name used to reference the model is configurable via [vash.config.modelName][]. Typical values are `model` and `it`.\n\n\n<a name=\"advanced-expressions\"></a>Advanced Expressions \n----------------------------\n\nVash typically knows when an expression ends, even when the expression is complex. For example:\n\ninput:\n\n\t<p>@model.what().who[2]('are you sure')('yes, it\\'s ok')( model.complex ? 'FULL POWER' : '' )</p>\n\nThis will work just fine, assuming you have a model that actually contains that complexity! I hope you don't, and if so, I feel bad.\n\nCallbacks work as well:\n\ninput:\n\n\t// model = ['a', 'b']\n\t@model.forEach(function(item){\n\t\t<li>@item</li>\n\t})\n\noutputs:\n\n\t<li>a</li><li>b</li>\n\nVash also knows the difference between JS dot notation and a period.\n\ninput:\n\n\t// model = { description: 'living' }\n\t<p>Plants are @model.description.</p>\n\noutput:\n\n\t<p>Plants are living.</p>\n\nAnd empty brackets, because they're not valid JS:\n\ninput:\n\n\t// model = { formName: 'addresses' }\n\t<input type=\"text\" name=\"@model.formName[]\" />\n\noutput:\n\n\t<input type=\"text\" name=\"addresses[]\" />\n\nEmail addresses, to an extent, are fine as well. Vash makes a trade-off. It uses the following regex to validate an email address:\n\n\t/^([a-zA-Z0-9.%]+@[a-zA-Z0-9.\\-]+\\.(?:ca|co\\.uk|com|edu|net|org))\\b/\n\nEmail addresses can actually contain many more valid characters, and are [really hard to validate][]. Vash can handle a typical email address with ease:\n\ninput:\n\n\t<a href=\"mailto:vash@planetgunsmoke.com\">Email Me</a>\n\noutput:\n\n\t<a href=\"mailto:vash@planetgunsmoke.com\">Email Me</a>\n\nIf you have a complex email address that confuses Vash, then you should use an [explicit expression](#explicit-expressions) instead.\n\n[really hard to validate]: http://www.regular-expressions.info/email.html\n\n<a name=\"explicit-expressions\"></a>Explicit Expressions \n----------------------------\n\nAn explicit expression is simply an expression that, instead of being composed of `@` and a valid JS identifier, is surrounded by parenthesis.\n\ninput:\n\n\t<p>@(model.what)</p>\n\noutput:\n\n\t<p>hello!</p>\n\nWhy would you ever need this? Perhaps you want to do something like:\n\ninput:\n\n\t// model = { hasIceCream: true }\n\t<p class=\"@( model.hasIceCream ? 'ice-cream' : '')\">Ice Cream<p>\n\noutput:\n\n\t<p class=\"ice-cream\">Ice Cream<p>\n\nYou could even create an anonymous function.\n\ninput:\n\n\t@(function(type){ return type + ' cream'; }('banana'))\n\noutput:\n\n\tbanana creme\n\nAs you can see, Vash does not require a model to be referenced, or even passed in.\n\n<a name=\"code-blocks\"></a>Code Blocks \n-------------------\n\nSometimes, AGAINST ALL ODDS, a template may need some quick computation of values to avoid repeating yourself. Unlike expressions and explicit expressions, a code block does not directly output. To compare to PHP, expressions are like `<?= $what ?>`, while a code block is like `<? $what = 'what' ?>`.\n\nA code block is simply `@{  }`.\n\ninput:\n\n\t@{ var rideOn = 'shooting star'; }\n\noutput:\n\nThat's right, _nothing_! Here's a better example:\n\ninput:\n\n\t@{\n\t\tvar total = model.price + model.tax;\n\t}\n\n\t<p>Your total is: $@total</p>\n\noutput:\n\n\t<p>Your total is: $2.70</p>\n\nAnything is valid within a code block, such as function declarations or even something as complex as defining a prototype. You can also use markup within a code block, and it will behave as expected:\n\ninput:\n\n\t@{ <p>This works!</p> }\n\noutput:\n\n\t<p>This works!</p>\n\nA code block just tells Vash, \"expect the next stuff to be code until otherwise\".\n\n<a name=\"keyword-blocks\"></a>Keyword Blocks \n----------------------\n\nVash is aware of keywords, and will open a code block automatically for you.\n\ninput:\n\n\t// model = { type: 'banana' }\n\t@if(model.type){\n\t\t<p>I'm a @model.type!</p>\n\t} else if(model.name){\n\t\t<p>My name is @model.name.</p>\n\t} else {\n\t\t<p>I DON'T KNOW WHO OR WHAT I AM...</p>\n\t}\n\noutput:\n\n\t<p>I'm a banana!</p>\n\nThis also works for `while`, `for`, `do`, `try/catch`, `with`, `switch`, `function`, and other keywords.\n\nYou don't even need to worry about whitespace or newlines:\n\ninput:\n\n\t// model = 1\n\t@switch(model){case 1:<p></p>break;case 2:<b></b>break;}\n\noutput:\n\n\t<p></p>\n\n<a name=\"comments\"></a>Comments \n----------------\n\nVash also supports comments that are not compiled into the template. These are delineated with `@*` and `*@`\n\ninput:\n\n\t@* I am a comment that extends\n\tover multiple lines *@\n\t<p>BANANA!</p>\n\noutput:\n\n\t<p>BANANA!</p>\n\n<a name=\"html-escaping\"></a>HTML Escaping \n---------------------\n\nBy default, Vash escapes any HTML-like values before outputting them.\n\ninput:\n\n\t// model = { what: '<img />' }\n\t<p>@model.what</p>\n\noutput:\n\n\t<p>&lt;img /&gt;</p>\n\nIf you are sure that you trust the content and/or need to display HTML-like values, you can escape the HTML escaping via a call to Vash's [helper system][]: `html.raw`.\n\ninput:\n\n\t// model = { what: '<img />' }\n\t<p>@html.raw(model.what)</p>\n\noutput:\n\n\t<p><img /></p>\n\nThis behavior can be disabled using [vash.config.htmlEscape][].\n\n<a name=\"explicit-markup\"></a>Explicit Markup \n-----------------------\n\nSometimes you may wish to tell Vash that what you're typing is markup or content, as opposed to code. Take the following example:\n\ninput:\n\n\t// model = ['a']\n\t@model.forEach(function(item){\n\t\titem\n\t})\n\noutput:\n\n\t(empty string)\n\nIn this situation, you have two options. The first is the `@:` (at colon) escape. It tells Vash that until it sees a newline, treat the input as content, not code.\n\ninput:\n\n\t// model = ['a']\n\t@model.forEach(function(item){\n\t\t@: item\n\t})\n\noutput:\n\n\ta\n\nThe other option, in the event that more than one line is needed, is by using an imaginary HTML tag named `<text>`. When Vash sees this tag, it switches to content mode, and discards the tag. This means that the tag will never be output.\n\ninput:\n\n\t// model = ['Indeed!']\n\t@model.forEach(function(item){\n\t\t<text>\n\t\t\tThis is some longer content that you\n\t\t\tapparently wanted on multiple lines,\n\t\t\tmultiple times! @item\n\t\t</text>\n\t})\n\noutput:\n\n\tThis is some longer content that you\n\tapparently wanted on multiple lines,\n\tmultiple times! Indeed!\n\n<a name=\"configuration\"></a>Configuration \n=====================\n\nVash has a few compilation options that are configurable either by setting the relevant value in `vash.config` or by passing in an object with that key/value to [vash.compile][], [vash.compileBatch][], or [vash.compileHelper][].\n\nFor example:\n\n\tvash.config.debug = true;\n\nIs the global version of:\n\n\tvash.compile('<p>My tpl</p>', { debug: true });\n\n<a name=\"vash-config-usewith\"></a>vash.config.useWith \n---------------------------\n\n\tDefault: false\n\nIf `useWith` is set to `true`, then Vash will wrap a `with` block around the contents of the compiled function.\n\n\t// vash.config.useWith == true\n\t<li>@description</li>\n\nvs\n\n\t// vash.config.useWith == false\n\t<li>@model.description</li>\n\nRendering is the same regardless:\n\n\ttpl( { description: 'I am a banana!' } );\n\t// outputs:\n\t// <li>I'm a banana!</li>\n\n_Tech note: using a `with` block comes at a severe performance penalty (at least 25x slower!)._\n\n<a name=\"vash-config-modelname\"></a>vash.config.modelName \n-----------------------------\n\n\tDefault: 'model'\n\nIf [vash.config.useWith][] is  `false` (default), then this property is used to determine what the name of the default free variable will be. Example:\n\n\t// vash.config.useWith == false\n\t<li>@model.description</li>\n\nvs\n\n\t// vash.config.useWith == false\n\t// vash.config.modelName == 'whatwhat'\n\t<li>@whatwhat.description</li>\n\nAgain, rendering is the same regardless:\n\n\ttpl( { description: 'I am a banana!' } );\n\t// outputs:\n\t// <li>I'm a banana!</li>\n\nA common alternative to `model` is `it`.\n\n<a name=\"vash-config-helpersname\"></a>vash.config.helpersName \n-------------------------------\n\n\tDefault: 'html'\n\nDetermines the name of the free variable through which registered helper methods can be reached. Example:\n\n\t<li>@html.raw(model.description)</li>\n\nvs\n\n\t// vash.config.helpersName == \"help\";\n\t<li>@help.raw(model.description)</li>\n\nAgain, rendering is the same regardless:\n\n\ttpl( { description : '<strong>Raw</strong> content!' } );\n\t// outputs:\n\t// <li><strong>Raw</strong> content!</li>\n\n<a name=\"vash-config-htmlescape\"></a>vash.config.htmlEscape \n------------------------------\n\n\tDefault: true\n\nAs of version 0.4x, Vash automatically HTML encodes values generated by an explicit or implicit expression. To disable this behavior, set `htmlEscape` to `false`. For an more in depth example, see [HTML Escaping][].\n\nIf a value _should not_ be escaped, simply wrap it in a call to [vash.helpers.raw][].\n\n<a name=\"vash-config-debug\"></a>vash.config.debug \n-------------------------\n\n\tDefault: true\n\nBy default, templates are compiled with extensive debugging information, so if an error is thrown while rendering a template (not compiling), exact location (line, character) information can be given.\n\nUsing the following template:\n\n\t<p></p>\n\nA template with `debug` set to `true` (default):\n\n\tfunction anonymous(model,html,__vopts,vash) {\n\t\ttry {\n\t\t\tvar __vbuffer = html.buffer;\n\t\t\thtml.options = __vopts;\n\t\t\tmodel = model || {};\n\t\t\thtml.vl = 1, html.vc = 0;\n\t\t\t__vbuffer.push('<p>');\n\t\t\thtml.vl = 1, html.vc = 3;\n\t\t\t__vbuffer.push('</p>');\n\t\t\thtml.vl = 1, html.vc = 7;\n\t\t\t__vbuffer.push('\\n');\n\t\t\t(__vopts && __vopts.onRenderEnd && __vopts.onRenderEnd(null, html));\n\t\t\treturn (__vopts && __vopts.asContext)\n\t\t\t\t? html\n\t\t\t\t: html.toString();\n\t\t} catch( e ){\n\t\t\thtml.reportError( e, html.vl, html.vc, \"<p></p>!LB!\" );\n\t\t}\n\t}\n\nAnd that same template with `debug` set to `false`:\n\n\tfunction anonymous(model,html,__vopts,vash) {\n\t\tvar __vbuffer = html.buffer;\n\t\thtml.options = __vopts;\n\t\tmodel = model || {};\n\t\t__vbuffer.push('<p></p>\\n');\n\t\t(__vopts && __vopts.onRenderEnd && __vopts.onRenderEnd(null, html));\n\t\treturn (__vopts && __vopts.asContext)\n\t\t\t? html\n\t\t\t: html.toString();\n\t}\n\nAs you can see, the difference, especially in code size and instruction size is significant. For production apps, templates should be precompiled with `debug` as `false`.\n\n<a name=\"vash-config-debugparser\"></a>vash.config.debugParser \n-------------------------------\n\n\tDefault: false\n\nVash's parser will output useful debugging infomation if `debugParser` is `true`:\n\n* Tokens and what mode they were processed as\n* A textual representation of the fully parsed AST\n\n<a name=\"vash-config-debugcompiler\"></a>vash.config.debugCompiler \n---------------------------------\n\n\tDefault: false\n\nVash's compiler will output useful debugging information if `debugCompiler` is `true`:\n\n* The text content of the template function before it is passed into [vash.link][] for actual evaluation\n* The options passed into the compiler. This is useful for debugging [vash.compileBatch][] and [vash.compileHelper][].\n\n<a name=\"vash-config-simple\"></a>vash.config.simple \n--------------------------\n\n\tDefault: false\n\nIf `true`, the template is compiled in \"fast path\" mode. This disables several advanced features for the sake of speed:\n\n* [onRenderEnd][] callbacks are completely ignored.\n* The [Helper System][] instance normally available within a running template as `html` is no longer an instance of `vash.helpers.constructor`, and thus the entire buffer API and helpers are missing. Instead it is a plain object with the following properties:\n  * `buffer`: a plain array\n  * `escape`: [vash.helpers.escape][]\n  * `raw`: [vash.helpers.raw][]\n* The [asContext][] runtime option is completely ignored.\n* [vash.config.htmlEscape][], [vash.config.useWith][], and [vash.config.debug][] still behave as expected.\n\nWhile standard Vash templates are definitely not slow, using `true` for this option decreases render time by 15% - 25% depending on the size of the template.\n\n[vash-benchgraph](https://github.com/kirbysayshi/vash-benchgraph) can be used to show the speed increase:\n\n\tnode benches.js --tinclude 004.vash,007.vash --vinclude '0.6.2-2482' --chart vashv,ops\n\n<a name=\"vash-config-favortext\"></a>vash.config.favorText \n-----------------------------\n\n\tDefault: false\n\nWhen Vash encounters text that directly follows an opening brace of a block, it assumes that unless it encounters an HTML tag, the text is JS code. For example:\n\n\t@it.forEach(function(a){\n\t\tvar b = a; // vash assumes this line is code\n\t})\n\nWhen `favorText` is set to `true`, Vash will instead assume that most things are content (not code) unless it's very explicit.\n\n\t@it.forEach(function(a){\n\t\tvar b = a; // vash.config.favorText assumes this line is content\n\t})\n\nThis option is __EXPERIMENTAL__, and should be treated as such. It allows Vash to be used in a context like [Markdown](http://daringfireball.net/projects/markdown/syntax), where HTML tags, which typically help Vash tell the difference between code and content, are rare.\n\n<a name=\"template-options\"></a>Template Options \n========================\n\nThese options concern rendering a template, after it has already been compiled. For options related to compiling templates, see [Configuration][].\n\nThe compiled templates themselves have three signatures.\n\n\ttpl(model) -> string\n\nThe most basic form accepts a single argument, `model`, that can be any value: Number, Boolean, Object, Array, undefined, null, etc. It returns the rendered template as a string.\n\n\ttpl(model, function(){}) -> string\n\nThe second form accepts a function callback as its second parameter, which is called [onRenderEnd][] (see below).\n\n\ttpl(model, options) -> string\n\nThe third form allows for options in addition to [onRenderEnd][]. There are two options that can affect a template while rendering:\n\n<a name=\"ascontext\"></a>asContext \n-----------------\n\n\ttpl(model, { asContext: true }) -> vash.helpers.constructor\n\nThis option tells the template that instead of returning a string, it should return the \"render context\", otherwise known as an instance of `vash.helpers.constructor` ([Helper System][]).\n\n<a name=\"onrenderend\"></a>onRenderEnd \n-------------------\n\n\ttpl(model, { onRenderEnd: function(){} }) -> string\n\nThis option is effectively a callback for once primary execution of the rendering template has finished. The arguments passed to the callback are: `( err, html )`, where `err` is always `null` (for now), and `html` is the render context (instance of `vash.helpers.constructor`). This callback is not required, and is only called if defined (and has no default definition). The [Layout Helpers][] use this to know when all includes, prepends, appends, blocks, and extend calls have finished.\n\n[onRenderEnd][] can also be defined as a property of the model:\n\n\tvar model = { hey: 'what', onRenderEnd: function(err, ctx){ ... } }\n\n<a name=\"helper-system\"></a>Helper System \n===============\n\nVash's primary point of expandability lies in its Helper API. When a template is rendering, there is a free variable avaiable. This variable is, by default, named `html`. This name can be changed with the [vash.config.helpersName][] option. `html` is an instance of the prototype that is attached to `vash.helpers`. It's a bit confusing, but this is how it kind of works:\n\n\tvar Helpers = function(){}\n\tvash.helpers = Helpers.prototype;\n\tvash.helpers.constructor = Helpers;\n\nWhat this means is that any function that is attached to `vash.helpers` is available within a rendering template via `html`. For example:\n\n\t// defined in a JS file or script tag somewhere\n\tvash.helpers.echo = function(arg){ return arg; }\n\ninput:\n\n\t<p>@html.echo('hello!')</p>\n\noutput:\n\n\t<p>hello!</p>\n\nHere is a simple helper that converts text like \"This is a holdup!\" to \"this-is-a-holdup\":\n\n\tvash.helpers.mdHref = function(text){\n\t\treturn text\n\t\t\t.toLowerCase()\n\t\t\t.replace(/[^a-zA-Z0-9-_]+/g, '-')\n\t\t\t.replace(/^-+|\\n|-+$/g, '');\n\t}\n\nNotice how it's just JavaScript. Within a template, it could be accessed via `html.mdHref(\"This is a holdup!\")`.\n\n<a name=\"built-in-helpers\"></a>Built-in Helpers \n========================\n\n<a name=\"vash-helpers-raw\"></a>vash.helpers.raw \n------------------------\n\nAvailable as `html.raw` within an executing template. By default, all content that passes from a model to a template is HTML encoded. In the event that the text is trusted (or is already encoded), wrap the text in this function. For an example, see [HTML Escaping][];\n\n<a name=\"vash-helpers-escape\"></a>vash.helpers.escape \n---------------------------\n\nAvailable as `html.escape` within an executing template, this is the method Vash uses to HTML encode model values. It can also be used manually.\n\n<a name=\"vash-helpers-tplcache\"></a>vash.helpers.tplcache \n-----------------------------\n\nThe `tplcache` is just that, a place to put a global index of templates. This is used primarily for the more \"view engine\" aspects that Vash provides, as well as a default location for [precompiled templates][--target-namespace] using [vash(1)][].\n\n<a name=\"layout-helpers\"></a>Layout Helpers \n======================\n\nVash provides a relatively simple but powerful view engine whose API is borrowed directly from [Jade][]. Below is the API, but an example can be found at [vash-express-example][].\n\nCallbacks are used to maintain compatibility with typical JS syntax.\n\nWhen running in [nodejs][] and using [express][], Vash will automatically resolve and load templates using the same conventions as express itself, specifically [app.engine][]. When in the browser, Vash uses the same rules, but looks in [vash.helpers.tplcache][] instead.\n\n[nodejs]: http://nodejs.org\n[express]: http://expressjs.com\n[app.engine]: http://expressjs.com/api.html#app.engine\n[Jade]: http://jade-lang.org\n[vash-express-example]: https://github.com/kirbysayshi/vash-express-example/tree/master/views\n[layout.vash]: https://github.com/kirbysayshi/vash-express-example/blob/master/views/layout.vash\n[Layout.vash]: https://github.com/kirbysayshi/vash-express-example/blob/master/views/layout.vash\n\n\n\n<a name=\"vash-helpers-extend\"></a>vash.helpers.extend \n---------------------------\n\n\tvash.helpers.extend(parent_path, cb)\n\nThis is Vash's main form of inheritance for view templates. `parent_path` is the location or name of the template to be extended.\n\nA template can define various locations in itself that can be [overridden](#vash-helpers-block) or [added to](#vash-helpers-append). In addition, a template that calls `extend` can even be extended itself!\n\nIn the following example, this template extends another named [layout.vash][]. [Layout.vash][] defines an empty [block](#vash-helpers-block) named 'content', which is overrided in this example.\n\n\t@html.extend('layout', function(model){\n\t\t@html.block('content', function(model){\n\t\t\t<h1 class=\"name\">Welcome to </h1>\n\t\t})\n\t})\n\n_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if it is referenced in the content. This may change in a future version of Vash._\n\n\n<a name=\"vash-helpers-block\"></a>vash.helpers.block \n--------------------------\n\n\tvash.helpers.block(name)\n\nA block is essentially a placeholder within a template that can be overridden via another call to [vash.helpers.block][], or modified using [vash.helpers.append][] and [vash.helpers.prepend][].\n\n\tvash.helpers.block(name, cb)\n\nIf `cb` is defined, then it becomes default content for the block. The eventual contents of the block can still be overridden by a subsequent call to [vash.helpers.block][] using the same `name` value, either within the current template (silly) or in a template that extends this one using [vash.helpers.extend][]. If [vash.helpers.append][] or [vash.helpers.prepend][] are later called, their content is _added_ to the content defined in `cb`.\n\n\t@html.block('main', function(model){\n\t\t<p>Hello, I'm default content. It's nice to meet you.</p>\n\t})\n\n_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if it is referenced in the content. This may change in a future version of Vash._\n\n\n<a name=\"vash-helpers-append\"></a>vash.helpers.append \n---------------------------\n\n\tvash.helpers.append(name, cb)\n\n[vash.helpers.append][] is a way to control the content of a block from within an extending template. In this way, it allows templates to invert control over content \"above\" them.\n\nAn example is a navigation area. Perhaps there is a default navigation list that templates can add to:\n\n\t// layout.vash\n\t<ul>\n\t@html.block('main-nav', function(model){\n\t\t<li><a href=\"/\">Home</a></li>\n\t})\n\t</ul>\n\n\t// another.vash\n\t@html.extend('layout', function(model){\n\t\t@html.append('main-nav', function(){\n\t\t\t<li><a href=\"/another\">Another Link</a></li>\n\t\t})\n\t})\n\nThis would output when fully rendered:\n\n\t<li><a href=\"/\">Home</a></li>\n\t<li><a href=\"/another\">Another Link</a></li>\n\n_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if it is referenced in the content. This may change in a future version of Vash._\n\n\n<a name=\"vash-helpers-prepend\"></a>vash.helpers.prepend \n----------------------------\n\n\tvash.helpers.prepend(name, cb)\n\n[vash.helpers.prepend][] behaves nearly the same as [vash.helpers.append][] except that it places content at the beginning of a block instead of at the end. The previous example, if `prepend` were substituted for `append`, would render as:\n\n\t<li><a href=\"/another\">Another Link</a></li>\n\t<li><a href=\"/\">Home</a></li>\n\n_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if it is referenced in the content. This may change in a future version of Vash._\n\n\n<a name=\"vash-helpers-include\"></a>vash.helpers.include \n----------------------------\n\n\tvash.helpers.include(name, model)\n\nThis grabs the template `name` and executes it using `model` as the... model. [vash.helpers.include][] is used to literally include the contents of another template. It is analogous to a \"partial\" in other view engines. Except that there is a hidden power here... as included templates share the same \"view engine scope\" as other templates, and can thus call all of the layout helper functions, and it will _just work_. Thus, a block within an included template can append to a block defined in a parent. It can even use [vash.helpers.extend][]!\n\n<a name=\"compiled-helpers\"></a>Compiled Helpers \n========================\n\nA relatively new feature in Vash (added in 0.6), compiled helpers are a bit meta. They allow a developer to write a helper using Vash syntax instead of the manual buffer API. The below buffer API example `imgfigure` could be rewritten:\n\n\tvash.helpers.imgfigure = function(path, caption){\n\t\tvash.helpers.imgfigure.figcount = vash.helpers.imgfigure.figcount || 0;\n\t\tvar figcount = vash.helpers.imgfigure.figcount;\n\t\t<figure id=\"fig-@(figcount++)\">\n\t\t\t<img src=\"@path\" alt=\"@caption\" />\n\t\t\t<figcaption>Fig. @figcount: @caption</figcaption>\n\t\t</figure>\n\t}\n\nThere are two ways to compile a helper. The first is using [vash.compileHelper][], the second is using [vash(1)][]'s [--helper][] option.\n\n<a name=\"buffer-api\"></a>Buffer API \n==================\n\nWithin a helper (not a template), `this` refers to the current `Helpers` instance. Every instance has a `Buffer` that has methods to help easily add, subtract, or mark content put there by the rendering template.\n\nAdding to the buffer:\n\n\tvash.helpers.imgfigure = function(path, caption){\n\t\tvash.helpers.imgfigure.figcount = vash.helpers.imgfigure.figcount || 0;\n\t\tvar figcount = vash.helpers.imgfigure.figcount++;\n\t\tthis.buffer.push('<figure id=\"fig-' + figcount + '\">';\n\t\tthis.buffer.push('<img src=\"' + path + '\" alt=\"' + caption + '\" />';\n\t\tthis.buffer.push('<figcaption>Fig.' + figcount + ':' + caption + '</figcaption>';\n\t\tthis.buffer.push('</figure>');\n\t}\n\nHere is a more advanced example, which is [contained within Vash](https://github.com/kirbysayshi/vash/blob/master/src/vhelpers.js):\n\n\tvash.helpers.highlight = function(lang, cb){\n\n\t\t// context (this) is an instance of Helpers, aka a rendering context\n\n\t\t// mark() returns an internal `Mark` object\n\t\t// Use it to easily capture output...\n\t\tvar startMark = this.buffer.mark();\n\n\t\t// cb() is simply a user-defined function. It could (and should) contain\n\t\t// buffer additions, so we call it...\n\t\tcb();\n\n\t\t// ... and then use fromMark() to grab the output added by cb().\n\t\tvar cbOutLines = this.buffer.fromMark(startMark);\n\n\t\t// The internal buffer should now be back to where it was before this\n\t\t// helper started, and the output is completely contained within cbOutLines.\n\n\t\tthis.buffer.push( '<pre><code>' );\n\n\t\tif( helpers.config.highlighter ){\n\t\t\tthis.buffer.push( helpers.config.highlighter(lang, cbOutLines.join('')).value );\n\t\t} else {\n\t\t\tthis.buffer.push( cbOutLines );\n\t\t}\n\n\t\tthis.buffer.push( '</code></pre>' );\n\n\t\t// returning is allowed, but could cause surprising effects. A return\n\t\t// value will be directly added to the output directly following the above.\n\t}\n\nA `Mark` is effectively a placeholder that can be used to literally mark the rendered content, and later do something with that mark. Possibilities include inserting content at the mark, deleting content that follows a mark, and more. It is an internal constructor that is only ever created through the `Buffer#mark` method within a helper. Examples of `Mark` usage can be found in the [layout helpers code][].\n\n[layout helpers code]: https://github.com/kirbysayshi/vash/blob/master/src/vhelpers.layout.js\n\nTODO: Explain the Buffer methods:\n\n* mark\n* fromMark\n* spliceMark\n* empty\n* push\n* pushConcat\n* indexOf\n* lastIndexOf\n* splice\n* index\n* flush\n* toString\n* toHtmlString\n\n<a name=\"precompiling-templates\"></a>Precompiling Templates \n==============================\n\nTo save both processing time (compiling templates is not trivial) as well as bandwidth (no need to send the whole compiler to the client), Vash supports precompilation of templates. Any template that Vash compiles is given a method called `toClientString`. This method returns a string that can either be `eval`ed or sent to a remote client. For example:\n\n\t<p>Hello</p>\n\nCompiles to a function:\n\n\tfunction anonymous(model,html,__vopts,vash) {\n\t\tvar __vbuffer = html.buffer;\n\t\thtml.options = __vopts;\n\t\tmodel = model || {};\n\t\t__vbuffer.push('<p></p>\\n');\n\t\t(__vopts && __vopts.onRenderEnd && __vopts.onRenderEnd(null, html));\n\t\treturn (__vopts && __vopts.asContext)\n\t\t\t? html\n\t\t\t: html.toString();\n\t}\n\nIf `toClientString` is called on that function, the following is returned:\n\n\tvash.link( function anonymous(model,html,__vopts,vash) {\n\t\tvar __vbuffer = html.buffer;\n\t\thtml.options = __vopts;\n\t\tmodel = model || {};\n\t\t__vbuffer.push('<p></p>\\n');\n\t\t(__vopts && __vopts.onRenderEnd && __vopts.onRenderEnd(null, html));\n\t\treturn (__vopts && __vopts.asContext)\n\t\t\t? html\n\t\t\t: html.toString();\n\t}, {\"simple\":false,\"modelName\":\"model\",\"helpersName\":\"html\"} )\n\nThis string could then be sent to the client (probably prefixed with something like `TPLCACHE[\"name-of-template\"] = `). [vash(1)][] helps to automate this easily.\n\n<a name=\"vash-runtime-browser\"></a>Vash Runtime (Browser) \n====================\n\nThe Vash runtime is a set of functions that every executing template expects to be available. The runtime is automatically packaged with full Vash builds. However, if only precompiled templates are sent to the browser, then only the runtime must be sent. The runtime includes all helpers and a few standard functions, such as [HTML Escaping][].\n\nThere are two runtime builds:\n\n* [vash-runtime.min.js][]: This is the basic runtime. It contains everything a standard Vash template needs to execute.\n* [vash-runtime-all.min.js][]: This also includes the [Layout Helpers][]. It is roughly twice as large as `vash-runtime.min.js`. Unless you're using the Vash view system in the browser, this is probably not necessary.\n\n[vash-runtime.min.js]: https://github.com/kirbysayshi/vash/blob/master/build/vash-runtime.min.js\n[vash-runtime-all.min.js]: https://github.com/kirbysayshi/vash/blob/master/build/vash-runtime-all.min.js\n\n<a name=\"compile-time-api\"></a>Compile-time API \n=============\n\n<a name=\"vash-compile\"></a>vash.compile \n-----------------------------------------------\n\n\tvash.compile(str_template, opt_options) -> Function\n\nAt its core, Vash has a `compile` function that accepts a string and options, and returns a function, otherwise known as a compiled template. That function, when called with a parameter (otherwise known as a _model_), will use that parameter to fill in the template. A model can be any value, including `undefined`, objects, arrays, strings, and booleans.\n\n<a name=\"vash-compilehelper\"></a>vash.compileHelper \n-----------------------------------------------------\n\n\tvash.compileHelper(str_template, opt_options) -> Object\n\nSee [Compiled Helpers][] for more detail.\n\n<a name=\"vash-compilebatch\"></a>vash.compileBatch \n----------------------------------------------------\n\n\tvash.compileBatch(str_template, opt_options) -> Object\n\nThis function can take a single string containing many named templates, and output an object containing the compiled versions of those templates. A \"named template\" is of the form (similar to a `sourceURL`):\n\n\t//@batch = div\n\t<div>@model</div>\\n'\n\n\t//@batch = a\n\t<a>@model</a>'\n\nThis example contains two named templates, \"div\" and \"a\". If this example were passed as a single string to `compileBatch`:\n\n\tvar tpls = vash.compileBatch(theTplString);\n\nOne could be called:\n\n\ttpls.div('yes!');\n\t// returns: <div>yes!</div>\n\nThis is meant as a convenience function for developers. Putting each template in a separate file can get old, especially if a template is small. Instead, templates can be grouped together. The object returned also has a custom `toClientString` function, which serializes each template in the object automatically.\n\nAside from the newline following the \"name\" of the template, whitespace is ignored:\n\n\t//@              batch = div\n\t//@batch=div\n\t//         @batch =div\n\nEach is treated the same.\n\n<a name=\"runtime-api\"></a>Runtime API \n===================\n\n<a name=\"vash-link\"></a>vash.link \n---------------------------------------------------------\n\n\tvash.link(str_tpl, options) -> Function\n\tvash.link(func_tpl, options) -> Function\n\nThis is primarily an internal function, and has relatively complex behavioral differences depending on what options are passed in. It takes either a decompiled string function or function instance and \"links\" it by wrapping it in a closure that provides access to Vash's runtime functions. It also sets up things like `toClientString` and `toString`. It makes precompiled functions possible. As a developer working on Vash, it's best to take a look at the [source itself][].\n\n[source itself]: https://github.com/kirbysayshi/vash/blob/master/src/vruntime.js\n\n<a name=\"vash-lookup\"></a>vash.lookup \n-------------------\n\n\tvash.lookup(str_path) -> Function\n\nAttempts to grab a template from `vash.helpers.tplcache[str_path]`, and throws an exception if it is not found.\n\n\tvash.lookup(str_path, model) -> Function\n\nIf `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.\n\n<a name=\"vash-install\"></a>vash.install \n--------------------\n\n`vash.install` accepts a few signatures:\n\n\tvash.install(str_path, func_tpl) -> func_tpl\n\n\"Saves\" the template at `vash.helpers.tplcache[str_path]`.\n\n\tvash.install(str_path, str_tpl) -> func_tpl\n\nIf `vash.compile` is available (meaning the entire compiler is available, not just the runtime), then the string is automatically compiled. and saved at `vash.helpers.tplcache[str_path]`.\n\n\tvash.install(obj) -> obj\n\nIf an object containing string keys pointing at template functions is passed, then the object's keys are used as the keys for `vash.helpers.tplcache`. This is especially useful when using [vash.compileBatch][], as the result can be directly passed.\n\n<a name=\"vash-uninstall\"></a>vash.uninstall \n----------------------\n\n\tvash.uninstall(str_path) -> bool\n\nDeletes the key named `str_path` from `vash.helpers.tplcache`.\n\n\tvash.uninstall(func_tpl) -> bool\n\nLoops through all templates in `vash.helpers.tplcache`, and if a strict equality is successful, deletes that reference.\n\n<a name=\"vash-1\"></a>vash(1) \n===============\n\nVash also includes a commandline tool that enables easy integration of templates into a unix toolchain. For example, to compile this documentation, the following command is used:\n\n\tbin/vash <README2.vash --render --helpers <(bin/vash <docs/helpers/* --helper) > README2.md\n\nThis first grabs all files in `docs/helpers/`, and compiles them as Vash helpers using the [--helper][] option. These compiled helpers are then fed via a temporary named pipe into the `--helpers` option, which accepts a file. This option user the file (temporary, in this case) as helpers, and they are added to the rendering context's prototype (see [Helper System][]. Next, `README2.vash` is fed into [vash(1)][], which is told to both compile the input as a template, and render it immediately, using the `--render` option. Granted, this is not how bash actually handles it, but this explanation will suffice.\n\nIn short, this loads and compiles helpers necessary for this document, grabs the file, and renders the whole thing as plain markdown.\n\n`vash(1)` has many options:\n\n    -h, --help                          output usage information\n    -t, --target-namespace <namespace>  Assign template to a <namespace>. Recommended is `vash.helpers.tplcache` for view engine compatibility\n    -p, --property-name [name]          Assign template to property named <name>. Defaults to filename, and requires --target-namespace.\n    -f, --file <file>                   Compile the template in <file>\n    -j, --json <json>                   Pass options to the Vash compiler. See docs for valid options.\n    -o, --out <path>                    Write template into <path> directory\n    -u, --uglify                        Uglify the template, safely\n    -a, --no-autolink                   Wrap each template in `vash.link`.\n    -r, --render [json]                 Render the template using <json> as the model\n    -s, --separator [separator]         Templates are auto-named by concatenating the file path with [separator]\n    --helper                            Assume the input is a to-be-compiled helper\n    --helpers <file>                    Execute these compiled helpers\n\nSome of the options are explained in greater detail below.\n\n<a name=\"installation\"></a>Installation \n--------------------\n\n[vash(1)][] comes with Vash, so it will always be within `node_modules/vash/bin/`. However, a global install is also supported, which can be accomplished via:\n\n\tnpm install -g vash\n\n<a name=\"vash1--target-namespace\"></a>--target-namespace \n---------------------------------------------------\n\nAssigns the compiled template to a specific \"namespace\". This value only supports simple namespaces, such as `blah.who.what.something`.\n\nUsing this option while piping into [vash(1)][] __REQUIRES__ [--property-name][] to also be specified.\n\nExample:\n\n\t$ echo 'function(){}' | bin/vash \\\n\t--target-namespace \"vash.helpers.tplcache\" \\\n\t--property-name 'myTpl'\n\n\tvash = vash || {};\n\tvash.helpers = vash.helpers || {};\n\tvash.helpers.tplcache = vash.helpers.tplcache || {};\n\tvash.helpers.tplcache[\"myTpl\"]=vash.link( ... )\n\n<a name=\"vash1--property-name\"></a>--property-name \n-----------------------------------------------\n\nSpecifies what name to use when assigning the compiled template. Defaults to the filename specified with `--file`. If content is piped into [vash(1)][], then this option is __MANDATORY__.\n\n<a name=\"vash1--helper\"></a>--helper \n----------------\n\nThis instructs [vash(1)][] to call [vash.compileHelper][] instead of [vash.compile][], and assumes the input is a template that is meant to be a compiled helper.\n\nAn empty helper:\n\n\t$ echo 'vash.helpers.who = function(){}' | bin/vash --helper --json '{\"debug\":false}'\n\n\tvash.link( function anonymous() {\n\tvar __vbuffer = this.buffer;\n\tvar model = this.model;\n\tvar html = this;\n\t{}\n\t}, {\"simple\":false,\"modelName\":\"model\",\"helpersName\":\"html\",\"args\":[\"\"],\"asHelper\":\"who\"} )\n\nAnd without `--helper`, `vash(1)` just outputs an empty template:\n\n\t$ echo 'vash.helpers.who = function(){}' | bin/vash --json '{\"debug\":false}'\n\n\tvash.link( function anonymous(model,html,__vopts,vash) {\n\tvar __vbuffer = html.buffer;\n\thtml.options = __vopts;\n\tmodel = model || {};\n\t__vbuffer.push('vash.helpers.who = function(){}\\n');\n\t(__vopts && __vopts.onRenderEnd && __vopts.onRenderEnd(null, html));\n\treturn (__vopts && __vopts.asContext)\n\t  ? html\n\t  : html.toString();\n\t}, {\"simple\":false,\"modelName\":\"model\",\"helpersName\":\"html\"} )\n\n<a name=\"contributing-building\"></a>Contributing / Building \n====================\n\nPlease see [CONTRIBUTING.md][]. In general, if you want something that Vash doesn't have, file a ticket. Pull Requests are also _always_ welcome!\n\n[CONTRIBUTING.md]: https://github.com/kirbysayshi/vash/CONTRIBUTING.md\n\n<a name=\"getting-help\"></a>Getting Help \n====================\n\nFile a ticket! Or hit me up on Twitter: @KirbySaysHi\n\n<a name=\"special-thanks\"></a>Special Thanks \n======================\n\nExtreme thanks goes to TJ Holowaychuck and his template engine [Jade](http://jade-lang.org). It was the original inspiration for Vash's lexer, [Layout Helpers][], and error reporting, and has been a constant source of inspiration and motivation.\n\nSome of the techniques Vash's compiler uses were directly inspired from [doT](https://github.com/olado/doT).\n\nDev doc styling (gfm.css) from https://gist.github.com/andyferra/2554919.\n\nAnd of course to Vash's [contributors][].\n\n[contributors]: https://github.com/kirbysayshi/vash/AUTHORS\n\n<a name=\"license\"></a>License \n===============\n\n[MIT](https://github.com/kirbysayshi/vash/LICENSE)\n\n[Features]: #features\n[Syntax Example]: #syntax-example\n[Quick Start]: #quick-start\n[nodejs]: #nodejs\n[express]: #express\n[Browser - Vanilla]: #browser---vanilla\n[Browser - RequireJS]: #browser---requirejs\n[Playground]: #playground\n[Syntax]: #syntax\n[The Transition Character: @]: #the-transition-character\n[Expressions]: #expressions\n[Advanced Expressions]: #advanced-expressions\n[Explicit Expressions]: #explicit-expressions\n[Code Blocks]: #code-blocks\n[Keyword Blocks]: #keyword-blocks\n[Comments]: #comments\n[HTML Escaping]: #html-escaping\n[Explicit Markup]: #explicit-markup\n[Configuration]: #configuration\n[vash.config.useWith]: #vash-config-usewith\n[vash.config.modelName]: #vash-config-modelname\n[vash.config.helpersName]: #vash-config-helpersname\n[vash.config.htmlEscape]: #vash-config-htmlescape\n[vash.config.debug]: #vash-config-debug\n[vash.config.debugParser]: #vash-config-debugparser\n[vash.config.debugCompiler]: #vash-config-debugcompiler\n[vash.config.simple]: #vash-config-simple\n[vash.config.favorText]: #vash-config-favortext\n[Template Options]: #template-options\n[asContext]: #ascontext\n[onRenderEnd]: #onrenderend\n[Helper System]: #helper-system\n[Built-in Helpers]: #built-in-helpers\n[vash.helpers.raw]: #vash-helpers-raw\n[vash.helpers.escape]: #vash-helpers-escape\n[vash.helpers.tplcache]: #vash-helpers-tplcache\n[Layout Helpers]: #layout-helpers\n[vash.helpers.extend]: #vash-helpers-extend\n[vash.helpers.block]: #vash-helpers-block\n[vash.helpers.append]: #vash-helpers-append\n[vash.helpers.prepend]: #vash-helpers-prepend\n[vash.helpers.include]: #vash-helpers-include\n[Compiled Helpers]: #compiled-helpers\n[Buffer API]: #buffer-api\n[Precompiling Templates]: #precompiling-templates\n[Vash Runtime (Browser)]: #vash-runtime-browser\n[Compile-time API]: #compile-time-api\n[vash.compile]: #vash-compile\n[vash.compileHelper]: #vash-compilehelper\n[vash.compileBatch]: #vash-compilebatch\n[Runtime API]: #runtime-api\n[vash.link]: #vash-link\n[vash.lookup]: #vash-lookup\n[vash.install]: #vash-install\n[vash.uninstall]: #vash-uninstall\n[vash(1)]: #vash-1\n[Installation]: #installation\n[--target-namespace]: #vash1--target-namespace\n[--property-name]: #vash1--property-name\n[--helper]: #vash1--helper\n[Contributing / Building]: #contributing-building\n[Getting Help]: #getting-help\n[Special Thanks]: #special-thanks\n[License]: #license\n\n\n<hr /><ol class=\"footnotes\">\n\t<li id=\"fn:razor-ms\">\n\t\t\t Razor syntax was developed at Microsoft, and typically refers to their Razor View Engine, which ships with ASP.NET MVC 3 and above. In this document, \"Razor\" will refer to the Razor View Engine, while \"syntax\" or \"Vash syntax\" refers to Vash's implementation.\n <a rev=\"footnote\" href=\"#fnref:razor-ms\">&#8617;</a>\n\t\t</li><li id=\"fn:this-doc\">\n\t\t\t This document starts off as a [Vash template][] that is then compiled and rendered via [vash(1)][] into markdown! It uses several custom helpers that are not shipped with Vash, but are of course available [for perusal][]. They include things like these footnotes and an autogenerated and linked table of contents.\n <a rev=\"footnote\" href=\"#fnref:this-doc\">&#8617;</a>\n\t\t</li>\n\t</ol>\n\n[Vash template]: https://github.com/kirbysayshi/vash/README.vash\n[for perusal]: https://github.com/kirbysayshi/vash/docs/helpers/md.vash\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/kirbysayshi/vash/issues"
  },
  "_id": "vash@0.7.12-1",
  "_shasum": "13f188237eea3dac3e2e11d9f77ae283e3776540",
  "_from": "vash@*",
  "_resolved": "https://registry.npmjs.org/vash/-/vash-0.7.12-1.tgz"
}
